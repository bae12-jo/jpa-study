# QueryDSL
* Spring Boot + JPA + Spring Data JPA 로 해결하지 못하는 복잡한 쿼리와 동적쿼리를 해결할 수 있음
* 쿼리를 자바 코드로 작성할 수 있고 문법 오류를 컴파일 시점에 잡아준다.
* 쉬운 SQL 스타일의 문법을 사용한다.

```java
@Test
public void jpql(){
  String username = "kim";
  String query = "select m from Member m"
                  + "where m.username = :username"; // 문법 오류 있으나 실행을 해야 발견됨
  List<Member> result = em.createQuery(query, Member.class).getResultList();
}

@Test
public void querydsl(){
  String username = "kim";
  List<Member> result = queryFactory // 자바 컴파일러가 오타 잡아줌
                        .select(member)
                        .from(member)
                        .where(member.username.eq(username)) // 코드 자동 완성 도움 받을 수 있음
                        .fetch();
}
```

# JPQL vs QueryDSL
* QueryDSL은 Criteria와 같이 JPQL 빌더 역할을 한다. 결국 JPQL를 생성하는 것은 동일하다.
* 차이점은 QueryDSL은 파라미터 바인딩을 자동으로 해준다는 것과 컴파일 시점에 오류 발견이 가능하다는 점이다.

```java
@Test
public void startJPQL(){
  String qlString = "select m from Member m where m.username = :username"; // 파라미터 바인딩을 해줌
  Member findMember = em.createQuery(qlString, Member.class)
              .setParameter("username", "member1")
              .getSingleResult();
  Assertions.assertThat(findMember.getUsername().isEqualTo("member1"));
}

@Test
publci void startQuerydsl(){
  // (1) com.mysema.query.jpa.impl.JPAQuery 객체를 생성
  JPAQeuryFactory queryFactory = new JPAQueryFactory(em); // 엔티티 매니저를 생성자로 넘겨줘야함, thread-safe하므로 필드로 빼도 됨
  // (2) 쿼리 타입(Q)을 생성
  QMember = new QMember("m"); // 별칭을 붙여주는 것 (Q타입 내에 있는 기본 인스턴스 member를 이용해도 됨)
  Member findMember = queryFactory
                        .select(m)
                        .from(m)
                        .where(m.username.eq("member1")) // 파라미터 바인딩을 해주지 않아도 prepared statement로 자동 바인딩
                        .fetchOne();
   assertThat(findMember.getUsername().isEqualTo("member1"));

}
```

# 기본 Q 타입
* 프로젝트 > querydsl > entity > QMember.java 파일 안에 generated code 있음
* 하이버네이트에 `use_sql_comment: true` 옵션을 지정해주면 jpql이 실행된 쿼리를 콘솔에서 확인 가능
```java
// (1) 직접 지정 -- 같은 테이블을 join 하는 경우가 아니면 거의 쓸 일이 없음
QMember qMember = new QMember("m");

// (2) 기본 인스턴스 사용하기
QMember qMember = QMember.member;

// (3) 기본 인스턴스를 static으로 선언 -- 권장
import static 프로젝트명.domain.QMember.member;

@Test
publci void startQuerydsl(){
  Member findMember = queryFactory
                        .select(member)
                        .from(member)
                        .where(member.username.eq("member1"))
                        .fetchOne();
   assertThat(findMember.getUsername().isEqualTo("member1"));

}
```

# 검색 조건 쿼리
```java
@Test
public void searchAdnParam(){
  queryFactory
        .selectFrom(member)
        .where(member.usernae.eq("member1") 
          .and(member.age.eq(10)) // where 절에는 and(), or() 메소드를 체인으로 연결 가능
        .fetchOne();
  assertThat(findMember.getUsername().isEqualTo("member1"));
}
```
* 검색 조건은 eq, not, in, notIn, between, goe, gt, loe, lt, linke, contains, startsWith
```java
member.username.eq("member1") // username = 'member1' 
member.username.ne("member1") //username != 'member1' 
member.username.eq("member1").not() // username != 'member1' 
member.username.isNotNull() //이름이 is not null 
member.age.in(10, 20) // age in (10,20) 
member.age.notIn(10, 20) // age not in (10, 20) 
member.age.between(10,30) //between 10, 30 
member.age.goe(30) // age >= 30 
member.age.gt(30) // age > 30 
member.age.loe(30) // age <= 30 
member.age.lt(30) // age < 30 
member.username.like("member%") //like 검색 
member.username.contains("member") // like ‘%member%’ 검색 member.username.startsWith("member") //like ‘member%’ 검색
```
* JPQL에서 지원하는 모든 걸 사용 가능

```java
@Test
public void searchAndParam(){
  queryFactory
        .selectFrom(member)
        .where(
          member.usernmae.eq("member1"),
          member.age.eq(10), null // and()메소드를 파라미터로 처리 가능, 중간이 null이 들어가면 무시되므로 동적 쿼리 작성 시 유리함
          )
        .fetchOne();
  assertThat(findMember.getUsername().isEqualTo("member1"));
}
```

# 결과 조회
http://querydsl.com/static/querydsl/4.4.0/apidocs/com/querydsl/core/Fetchable.html
* fetch(): 리스트 조회, 데이터 없으면 빈 리스트 반환 // list()
* fetchOne(): 단건 조회 // uniqueResult()
  * 결과 없으면 null
  * 결과가 둘 이상이면 com.querydsl.core.NonUniqueResultException
* fetchFirst(): limit(1).fetchOne() // singleResult()
* fetchResults(): 페이징 정보 포함, total count 쿼리 추가 실행 (decprecated)
* fetchCount(): count 쿼리로 변경해서 count 수 조회

http://querydsl.com/static/querydsl/3.0.0/apidocs//com/mysema/query/Projectable.html
* list(): 결과가 하나 이상일 때 사용, 결과가 없으면 빈 컬렉션 반환
* uniqueResult(): 조회 결과가 한건일 때 사용
  * 조회 결과가 없으면 null 반환
  * 하나 이상이면 com.mysema.query.NonUniqueResultException()
* singleResult(): 결과가 하나 이상이면 첫번째 데이터를 반환

# 정렬
```java
/**
* 회원 정렬 순서
* 1. 회원 나이 내림차순(desc)
* 2. 회원 이름 오름차순(asc)
* 단 2에서 회원 이름이 없으면 마지막에 출력(nulls last)
*/

@Test
public void sort(){
  em.persist(new Member(null, 100));
  em.persist(new Member("member5", 100));
  em.persist(new Member("member6", 100));
  
  queryFactory
      .selectFrom(member)
      .where(member.age.eq(100))
      .orderBy(member.age.desc(), member.username.asc().nullslast()) // nullsfirst() 옵션도 있음
      .fetch();
      
  Member member5 = result.get(0);
  Member member6 = result.get(1);
  Member memberNull = result.get(2);
  
  assertThat(member5.getUsername()).isEqualTo("member5");
  assertThat(member6.getUsername()).isEqualTo("member6");
  assertThat(memberNull.getUsername()).isNull();
}
```
# 페이징
```java
public void paing1(){
  List<Member> result = queryFactory
      .selectFrom(member)
      .orderBy(member.username.desc())
      .offset(1)
      .limit(2)
      .fetch();
      
  assertThat(result.size()).isEqualTo(2));
}

public void paing2(){
  QueryResults<Member> queryResults = queryFactory
      .selectFrom(member)
      .orderBy(member.username.desc())
      .offset(1)
      .limit(2)
      .fetchResults();
      
  assertThat(queryResults.getTotal()).isEqualTo(4)); // 4개를 만들어뒀다는 전제
  assertThat(queryResults.getLimit()).isEqualTo(2));
  assertThat(queryResults.getOffset()).isEqualTo(1));
  assertThat(queryResults.getResults().size()).isEqualTo(2));
  
}
```
* 실무에서는 count 쿼리를 별도로 작성하는 것이 더 간단할 때도 있음
* 복잡한 쿼리에서 count까지 함께 하려고 굳이 하지 않아도 됨 (성능도 애매함)

# 집합
```java
@Test public void aggregation() { 
List<Tuple> result = queryFactory // QueryDSL이 제공하는 Tuple로 값이 반환됨
  .select( 
    member.count(), 
    member.age.sum(), 
    member.age.avg(), 
    member.age.max(), 
    member.age.min() 
    ) 
  .from(member) 
  .fetch(); 
  
Tuple tuple = result.get(0); // 실무에서는 튜플보다는 DTO로 뽑아오는 방법을 주로 사용

assertThat(tuple.get(member.count())).isEqualTo(4); assertThat(tuple.get(member.age.sum())).isEqualTo(52); assertThat(tuple.get(member.age.avg())).isEqualTo(13); assertThat(tuple.get(member.age.max())).isEqualTo(15); assertThat(tuple.get(member.age.min())).isEqualTo(10); 
}
```

# 그룹
* JPQL이 제공하는 모든 집합 함수를 제공한다. (count, sum, avg, max, min)
```java
 @Test public void group() { 
  List<Tuple> result = queryFactory 
    .select(team.name, member.age.avg()) 
    .from(member) 
    .join(member.team, team) 
    .groupBy(team.name) 
    .fetch(); 
    
  Tuple teamA = result.get(0); 
  Tuple teamB = result.get(1); 
  
  assertThat(teamA.get(team.name)).isEqualTo("teamA");
  assertThat(teamB.get(team.name)).isEqualTo("teamB"); 
  }
```

# groupBy
* groupBy() 메소드를 체인하여 사용한다.
```java
 @Test public void group() { 
  List<Tuple> result = queryFactory 
    .select(team.name, member.age.avg()) 
    .from(member) 
    .join(member.team, team) 
    .groupBy(team.name) 
    .fetch(); 
    
 Tuple teamA = result.get(0); 
 Tuple teamB = result.get(1); 
 
 assertThat(teamA.get(team.name)).isEqualTo("teamA");
 assertThat(teamB.get(team.name)).isEqualTo("teamB"); 

}
```
* 그룹화된 결과를 제한하려면 having() 메소드를 체인하여 사용하면 된다.
```java
.groupBy(item.price)
.having(item.price.gt(1000))
```

# 조인
## 기본 조인
* `join(조인 대상, 별칭으로 사용할 Q타입)`을 사용하면 된다.
* join(), innerjoin()
* leftJoin(): left outer join
* rightJoin(): right outer join
* on() 메소드도 사용 가능하다.
```java
@Test public void join() { 
  List<Member> result = queryFactory 
    .selectFrom(member) 
    .join(member.team, team)
    .where(team.name.eq("teamA")) 
    .fetch(); 
    
 assertThat(result) 
  .extracting("username") 
  .containsExactly("member1", "member3"); 
}
```

## 세타조인
* 연관관계가 없는 필드끼리 조인할 때 사용
* `from(필드, 필드)` 형태로 연관 없는 엔티티를 나열하면 됨 (다 불러와서 조건에 맞는 걸 구하는 방식, DB가 알아서 최적화해줌)
* 세타조인은 원칙적으로 outer join이 불가능함 (cartesian곱한 후 on메소드를 이용해서 할 수 있음)

```java
// 시나리오: 회원 이름과 팀 이름이 같은 사람 조회
@Test public void theta_join() { 
  em.persist(new Member("teamA")); 
  em.persist(new Member("teamB")); 
  em.persist(new Member("teamC")); 
  
List<Member> result = queryFactory 
  .select(member) 
  .from(member, team) 
  .where(member.username.eq(team.name)) 
  .fetch(); 
  
assertThat(result) 
  .extracting("username") 
  .containsExactly("teamA", "teamB"); }

```

## on절
### (1) 조인 대상 필터링
```java
/**
 * 예) 회원과 팀을 조인하면서, 팀 이름이 teamA인 팀만 조인, 회원은 모두 조회
 * JPQL: SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = 'teamA'
 * SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.TEAM_ID=t.id and 
t.name='teamA'
 */
 
@Test public void join_on_filtering() { 
  List<Member> result = queryFactory 
    .selectFrom(member) 
    .leftJoin(member.team, team) // 이런식으로 하면 FK를 대조하여 조인 on member0_.team_id=team1_.team_id
    .on(team.name.eq("teamA"))
    .where(team.name.eq("teamA")) 
    .fetch(); 
}
```
* 참고) on 절을 활용해 조인 대상을 필터링 할 때, 외부조인이 아니라 내부조인(inner join)을 사용하면, where 절에서 필터링 하는 것과 기능이 동일하다. 따라서 on 절을 활용한 조인 대상 필터링을 사용할 때,내부조인 이면 익숙한 where 절로 해결하고, 정말 외부조인이 필요한 경우에만 이 기능을 사용하자

### (2) 연관관계 없는 엔티티 외부 조인
```java
/**
 * 2. 연관관계 없는 엔티티 외부 조인
 * 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
 * JPQL: SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name
 * SQL: SELECT m.*, t.* FROM Member m LEFT JOIN Team t ON m.username = t.name
 */
 
@Test public void theta_on_no_relation() { 
  List<Tuple> result = queryFactory 
    .select(member, team)
    .from(member) 
    .leftJoin(team) // 이런식으로 하면 FK를 대조하지 않고 조인함 member.team_id와 team.team_id를 대조하지 않음
    .on(member.username.eq(team.name)) 
    .fetch(); 
}
```
* member와 team에서 이름이 같으면 전부 join한 다음, 두 이름이 같은 것만 필터링해서 fetch하는 것
* 일단 조인 `leftJoin(member.team, team)`과의 문법적 차이 있으므로 주의

## 페치조인
* 주로 성능 최적화를 위해 사용한다 (n+1문제도 해결 가능)
* 연관관계가 있는 엔티티들을 한꺼번에 조회해주는 조인 기능이다.
```java
/*
* 적용 전
*/

@PersistenceUnit // 테스트 증명을 위해 엔티티매니저팩토리 생성
EntityManagerFactory emf;

@Test
public void fetchJoinNo() throws Exception {
   // 페치조인을 테스트할 때는 영속성 컨텍스트를 깨끗히 지우고 하기
   em.flush();
   em.clear();
   Member findMember = queryFactory
     .selectFrom(member)
     .where(member.username.eq("member1"))
     .fetchOne();
     
   boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam()); // 해당 엔티티가 로딩되었는지 초기화가 안되었는지 알려줌 (isLoaded)
   assertThat(loaded).as("페치 조인 미적용").isFalse(); // 현재 로딩 안되었으니까 false가 나옴
}

/*
* 적용 후
*/

@PersistenceUnit // 테스트 증명을 위해 엔티티매니저팩토리 생성
EntityManagerFactory emf;

@Test
public void fetchJoinNo() throws Exception {
   // 페치조인을 테스트할 때는 영속성 컨텍스트를 깨끗히 지우고 하기
   em.flush();
   em.clear();
   Member findMember = queryFactory
     .selectFrom(member)
     .join(member.team, team).fetchJoin()
     .where(member.username.eq("member1"))
     .fetchOne();
     
   boolean loaded = emf.getPersistenceUnitUtil().isLoaded(findMember.getTeam()); // 해당 엔티티가 로딩되었는지 초기화가 안되었는지 알려줌 (isLoaded)
   assertThat(loaded).as("페치 조인 미적용").isFalse(); // 현재 로딩 안되었으니까 false가 나옴
}
```

# 서브 쿼리
* com.querydsl.jpa.JPAExpressions 사용
* JPA JPQL의 서브쿼리 한계점으로 from 절에서 서브쿼리는 지원하지 않는다. (in-line view 지원 안함)
* 하이버네이트 구현체를 사용하면 select 절의 서브쿼리를 지원한다. (JPA 표준 스펙에서는 지원 안 함)

```java
/**
 * 나이가 가장 많은 회원 조회
 */@Test
public void subQuery() throws Exception {
   QMember memberSub = new QMember("memberSub"); // alias가 중복되면 안 되는 경우 직접 명시
   List<Member> result = queryFactory
           .selectFrom(member)
           .where(member.age.eq(
                 JPAExpressions
                     .select(memberSub.age.max())
                     .from(memberSub)
           ))
           .fetch();
   assertThat(result).extracting("age")
   .containsExactly(40);
}

/**
 * 나이가 평균 나이 이상인 회원
 */
@Test
public void subQueryGoe() throws Exception {
     QMember memberSub = new QMember("memberSub");
         List<Member> result = queryFactory
         .selectFrom(member)
         .where(member.age.goe(
             JPAExpressions
                 .select(memberSub.age.avg())
                 .from(memberSub)
         ))
         .fetch();
assertThat(result).extracting("age")
.containsExactly(30,40);
}

/**
 * 서브쿼리 여러 건 처리, in 사용
 */
@Test
public void subQueryIn() throws Exception {
     QMember memberSub = new QMember("memberSub");
         List<Member> result = queryFactory
         .selectFrom(member)
         .where(member.age.in(
             JPAExpressions
                 .select(memberSub.age)
                 .from(memberSub)
                 .where(memberSub.age.gt(10))
          ))
         .fetch();
         
 assertThat(result).extracting("age")
 .containsExactly(20, 30, 40);
}

/**
 * select 절에 subquery
 */
List<Tuple> fetch = queryFactory
     .select(member.username,
           JPAExpressions
               .select(memberSub.age.avg())
               .from(memberSub)
     ).from(member)
     .fetch();
     
for (Tuple tuple : fetch) { System.out.println("username = " + tuple.get(member.username)); System.out.println("age = " + tuple.get(JPAExpressions.select(memberSub.age.avg())
 .from(memberSub)));
}
```

* from 절의 서브쿼리 해결방안
  1. 서브쿼리를 join으로 변경한다. (가능한 상황도 있고, 불가능한 상황도 있다.)
  2. 애플리케이션에서 쿼리를 2번 분리해서 실행한다.
  3. nativeSQL을 사용한다

# 프로젝션
* select절에 조회 대상을 지정하는 것
* 프로젝션 대상이 하나라면 타입을 명확하게 지정할 수 있다.
```java
@Test
public void simpleProjection(){
    List<String> result = queryFactory // List<Member>도 가능
         .select(member.username)
         .from(member)
         .fetch();
         
    for(String s: result){
      System.out.println("s = " + s);
    }
 }
```
* 2개 이상이라면 튜플이나 DTO로 조회한다.
* ```java
@Test
public void tupleProjection(){
    List<Tuple> result = queryFactory // com.querydsl.core -> repogitory 이상에서 사용하면 안 좋음, 하부 기술이 바뀔 때 쉽게 교체 가능해야 함
     .select(member.username, member.age)
     .from(member)
     .fetch();
         
    for (Tuple tuple : result) {
       String username = tuple.get(member.username);
       Integer age = tuple.get(member.age);
       System.out.println("username=" + username);
       System.out.println("age=" + age);
    }
 }
```

# DTO 조회
* 순수 JPA에서 DTO를 조회할 때는 new 명령어를 사용해야함
* DTO의 package이름을 다 적어줘야해서 지저분함
* 생성자 방식만 지원함
```java
package study.querydsl.dto;

import lombok.Data;
// import lombok.NoArgsConstructor;

@Test
public void findDTOByJPQL(){
List<MemberDto> result = em.createQuery(
   "select new study.querydsl.dto.MemberDto(m.username, m.age) " +
   "from Member m", MemberDto.class)
   .getResultList();
   
   for(MemberDto memberDto : result) {
      System.out.println("memberDto = " + memberDto);
   }
}

@Data
public class MemberDto {

     private String username;
     private int age;

     public MemberDto() {
     }

     public MemberDto(String username, int age) {
         this.username = username;
         this.age = age; 
     }
 
}
```

# 빈을 생성해서 객체를 받아오는 3가지 방법
## (1) 프로퍼티 접근
* 프로퍼티명이 동일해야 접근 가능
```java
@Test
public void findBySetter(){
    List<MemberDto> result = queryFactory
         .select(Projections.bean(MemberDto.class, // MemberDto에 setter를 만들어 둬야함
                 member.username,
                 member.age))
         .from(member)
         .fetch();
 }
```

## (2) 필드 직접 접근
* 필드명이 동일해야 접근 가능
```java
@Test
public void findBySetter(){
    List<MemberDto> result = queryFactory
         .select(Projections.fields(MemberDto.class, //getter, setter 없이 필드에 바로 들어감 
                 member.username,
                 member.age))
         .from(member)
         .fetch();
 }
```

## 프로퍼티나 필드 접근 시 이름이 다를 때
* ExpressionUtils.as(source,alias) : 필드나, 서브 쿼리에 별칭 적용
* username.as("memberName") : 필드에 별칭 적용
```java
List<UserDto> fetch = queryFactory
       .select(Projections.fields(UserDto.class,
               member.username.as("name"),
               ExpressionUtils.as(
                       JPAExpressions
                             .select(memberSub.age.max())
                             .from(memberSub), "age")
               )
       ).from(member)
       .fetch();
```

## (3) 생성자 사용
```java
@Test
public void findByConstructor(){
    List<MemberDto> result = queryFactory
         .select(Projections.constructor(MemberDto.class,
                 member.username,
                 member.age))
         .from(member)
         .fetch();
 }

# @QueryProjection
* @QueryProjection 어노테이션을 DTO 위에 해준 후, `./gradlew complieQueryDSL`을 하면 DTO이 Q파일로 생성됨
```java
package study.querydsl.dto;
import com.querydsl.core.annotations.QueryProjection;
import lombok.Data;
@Data
public class MemberDto {
     private String username;
     private int age;
     
     public MemberDto() {
     }
     
     @QueryProjection
     public MemberDto(String username, int age) {
         this.username = username;
         this.age = age;
     }
}

@Test
public void findDtoByQueryProjection(){
      List<MemberDto> result = queryFactory
           .select(new QMemberDto(member.username, member.age))
           .from(member)
           .fetch();
}
```
